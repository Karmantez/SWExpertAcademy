# 7396(D5) 종구의 딸이름 짓기

- URL :   https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWm8hNu6llcDFASj  
- 출처 : SW Expert Academy



## 개요

> 목표

N * M의 알파벳 소문자로 이루어진 2차원 배열에서 오른쪽, 아래로만 이동하여 사전순으로 가장 앞서는 문자열을 출력.



> 제약조건

- 19개 테스트케이스를 합쳐서 *C의 경우 5초* / *C++의 경우 5초* / *Java의 경우 10초* 
- 1 ≤ N, M ≤ 2,000
- 입력값은 모두 알파벳 소문자



> 그 외

- 가능한 문자열 중 사전 순으로 가장 앞선 것을 결과로 채택해야 한다.



## 계획

1. 2차원 배열을 만들어 원판을 표현하고 rotate(원판 돌리는 method)를 만들면 되겠다고 생각했습니다.
2. examine(인접한 숫자가 있는지 검사하는 method)이 2-for로 실행되기 때문에 N^{2} 이므로 최악의 경우, 50(T≤50\) * (50 * 50), 여기에 모든 원판(N≤50)을 50(T≤50)번 움직이고 N, M이 최대라고 가정하면, 50^{4}, 총 125,000 + 6,250,000 이므로 제한시간안에 결과가 나온다고 예측했습니다.



## 결과

**Accept/Fail : 1/5**

**메모리 : 123,460KB, 시간 : 286ms, 코드길이: 3,123B**

**문제풀이시간 : *하루***



## 회고

1. N, M의 최대가 2,000이여서 모두 탐색할 경우(N^2) 시간초과가 날 것이라 예상 했습니다. 그래서 DP로 풀어야 겠다고 생각하였습니다.
2. 똑같은 크기의 2차원 배열을 만들어서 해당 지점에서 만들 수 있는 사전 순으로 빠른 문자열을 저장했으나 시관초과가 발생하였습니다.
3. 분석을 해보니 이미 배열의 크기가 충분히 크기 때문에 DP에 저장하는 것만으로도 시간이 오래 걸렸습니다.
4. 그래서 BFS 탐색을 통해 방문했던 곳이면 다시 가지 않도록 하였습니다.
5. BFS 구현을 할 때 현재 가지고 있는 좌표(Location) 객체 중 가장 작은 문자값을 가지는 하나만을 남겨두었는데 해당 좌표에서 결과(N - 1, M - 1)까지 가는 경로가 최적이 아닌 경우가 있었습니다.
6. 그래서 제일 작은 문자열의 위치를 가지는 객체가 다수라면 모두 탐색 해보도록 수정하여서 해결 하였습니다.
7. 실행속도가 느린 이유는 한 번 반복 후, 정렬을 하기 때문인 것 같습니다.